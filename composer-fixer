#!/usr/bin/env php
<?php
declare(strict_types=1);

/**
 * This file is part of the guanguans/laravel-exception-notify.
 *
 * (c) guanguans <ityaozm@gmail.com>
 *
 * This source file is subject to the MIT license that is bundled.
 */

use Symfony\Component\Console\Input\ArgvInput;
use Symfony\Component\Console\Output\ConsoleOutput;
use Symfony\Component\Console\Style\SymfonyStyle;
use Symfony\Component\Process\Exception\ProcessFailedException;
use Symfony\Component\Process\PhpExecutableFinder;
use Symfony\Component\Process\Process;

require __DIR__.'/vendor/autoload.php';

(new class {
    private SymfonyStyle $symfonyStyle;
    private string $composerJsonFile;
    private string $composerBinary;
    private string $highestComposerBinary;

    public function __construct()
    {
        $this->symfonyStyle = new SymfonyStyle(new ArgvInput, new ConsoleOutput);
        $this->composerJsonFile = __DIR__.'/composer.json';
        $this->composerBinary = $this->findComposerBinary();
        $this->highestComposerBinary = $this->findComposerBinary('/opt/homebrew/opt/php@8.3/bin/php');
    }

    public function __invoke(): void
    {
        $this
            // ->updateComposerPackages()
            ->updateComposerJsonFile($this->updateComposerDecodedJson())
            // ->updateComposerPackages()
            ->normalizeComposerJsonFile()
            ->success();
    }

    private function getComposerDecodedJson(): array
    {
        /** @noinspection JsonEncodingApiUsageInspection */
        return json_decode(file_get_contents($this->composerJsonFile), true);
    }

    private function dependencyVersion(string $version): array
    {
        return array_slice(explode('.', ltrim($version, 'v'), 3), 0, 2);
    }

    private function updateComposerPackages(): self
    {
        $this->createAndMustRunProcess("{$this->composerBinary} update -W --ansi -v");

        return $this;
    }

    private function updateComposerJsonFile(array $composerDecodedJson): self
    {
        /** @noinspection JsonEncodingApiUsageInspection */
        file_put_contents(
            $this->composerJsonFile,
            json_encode(
                $composerDecodedJson,
                JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES
            ).PHP_EOL
        );

        return $this;
    }

    private function updateComposerDecodedJson(): array
    {
        $composerOutdatedPackages = $this->getComposerOutdatedPackages();
        $composerDecodedJson = $this->getComposerDecodedJson();

        foreach ($composerOutdatedPackages as $composerOutdatedPackage) {
            foreach (['require', 'require-dev'] as $environment) {
                if (isset($composerDecodedJson[$environment][$composerOutdatedPackage['name']])) {
                    $composerDecodedJson[$environment][$composerOutdatedPackage['name']] = $composerOutdatedPackage['dependency_version'];
                }
            }
        }

        return $composerDecodedJson;
    }

    private function normalizeComposerJsonFile(): self
    {
        $this->createAndMustRunProcess("{$this->composerBinary} normalize --diff --ansi -v");

        return $this;
    }

    /**
     * @param null|array|string $message
     */
    private function success($message = null): void
    {
        $this->symfonyStyle->success($message ?: 'Composer packages updated successfully!');

        exit(0);
    }

    private function getComposerOutdatedPackages(): array
    {
        /** @noinspection JsonEncodingApiUsageInspection */
        $outdatedPackages = json_decode(
            $this
                ->createAndMustRunProcess("{$this->highestComposerBinary} outdated --format=json --direct --ansi -v")
                ->getOutput(),
            true
        )['installed'];
        $outdatedPackages = array_filter($outdatedPackages, function (array $package) {
            return ! (
                '*' === $package['version']
                || str_contains($package['version'], '-')
                || str_contains($package['version'], '@')
            );
        });

        return array_map(
            function (array $package): array {
                $dependencyLowestVersion = $this->dependencyVersion($package['version']);
                $dependencyHighestVersion = $this->dependencyVersion($package['latest']);
                $dependencyVersion = '^'.implode('.', $dependencyLowestVersion);

                if ($dependencyLowestVersion[0] !== $dependencyHighestVersion[0]) {
                    $dependencyVersion = $dependencyVersion.' || '.implode(' || ', array_map(
                        static fn (string $main): string => "^$main.0",
                        range($dependencyLowestVersion[0] + 1, $dependencyHighestVersion[0])
                    ));
                }

                $package['dependency_version'] = $dependencyVersion;

                return $package;
            },
            $outdatedPackages
        );
    }

    private function updateComposerOutdatedPackage(string $composerOutdatedPackage, string $environment): void
    {
        try {
            $this->createAndMustRunProcess(sprintf(
                "{$this->composerBinary} require $composerOutdatedPackage %s --no-scripts -W --ansi -v",
                'require-dev' === $environment ? '--dev' : ''
            ));
        } catch (ProcessFailedException $processFailedException) {
            $this->symfonyStyle->error("Failed to update composer outdated [$composerOutdatedPackage] package version.");
        }
    }

    private function findComposerBinary(?string $phpBinary = null): string
    {
        return sprintf(
            '%s %s',
            $phpBinary ?? (new PhpExecutableFinder)->find(),
            (new Symfony\Component\Process\ExecutableFinder)->find('composer')
        );
    }

    /**
     * @param array|string $command
     * @param mixed $input The input as stream resource, scalar or \Traversable, or null for no input
     */
    private function createAndMustRunProcess(
        $command,
        ?string $cwd = null,
        ?array $env = null,
        $input = null,
        ?float $timeout = 60
    ): Process {
        $process = is_string($command)
            ? Process::fromShellCommandline($command, $cwd, $env, $input, $timeout)
            : new Process($command, $cwd, $env, $input, $timeout);

        $this->symfonyStyle->warning($process->getCommandLine());

        return $process
            ->setWorkingDirectory(dirname($this->composerJsonFile))
            ->setEnv(['COMPOSER_MEMORY_LIMIT' => -1])
            ->mustRun(fn (string $type, string $buffer) => $this->symfonyStyle->write($buffer));
    }
})();
